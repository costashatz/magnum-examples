// #version 430
layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

#ifndef LIGHT_COUNT
#define LIGHT_COUNT 1 // define this when compiling the shader
#endif

layout(binding = 0) uniform sampler3D voxelAlbedo;
layout(binding = 1, rgba8) uniform image3D voxelNormal;
layout(binding = 2, rgba8) uniform readonly image3D voxelEmissive;
layout(binding = 3, rgba8) uniform writeonly image3D voxelRadiance;

layout(location = 0)
uniform int volumeDimension;
layout(location = 1)
uniform float voxelSize;
layout(location = 2)
uniform float voxelScale;
layout(location = 3)
uniform vec3 worldMinPoint;
layout(location = 4)
uniform float traceShadowHit;

layout(location = 5)
uniform lightSource lights[LIGHT_COUNT];

float TraceShadow(vec3 position, vec3 direction, float maxTracingDistance)
{
    // scaling factor
    float k = traceShadowHit * traceShadowHit;
    // navigation
    float voxelTexSize = 1. / volumeDimension;
    // move one voxel further to avoid self collision
    float dst = voxelTexSize * 2.;
    vec3 samplePos = direction * dst + position;
    // control variables
    float visibility = 0.;
    // accumulated sample
    float traceSample = 0.;

    while (visibility <= 1. && dst <= maxTracingDistance)
    {
        if (samplePos.x < 0. || samplePos.y < 0. || samplePos.z < 0.
            || samplePos.x > 1. || samplePos.y > 1. || samplePos.z > 1.)
        {
            break;
        }

        traceSample = ceil(texture(voxelAlbedo, samplePos).a) * k;

        // hard shadows mode
        if(traceSample > 1. - EPSILON) { return 0.; }

        // accumulate
        visibility += (1. - visibility) * traceSample / dst;
        // move further into volume
        dst += voxelTexSize;
        samplePos = direction * dst + position;
    }

    return 1. - visibility;
}

// albedo should contain: material*lightDiffuse
vec3 BRDF(vec3 lightDirection, vec3 normal, vec3 albedo)
{
    float nDotL = 0.;

    vec3 weight = normal * normal;
    // calculate directional normal attenuation
    float rDotL = dot(vec3(1., 0., 0.), lightDirection);
    float uDotL = dot(vec3(0., 1., 0.), lightDirection);
    float fDotL = dot(vec3(0., 0., 1.), lightDirection);

    rDotL = normal.x > 0. ? max(rDotL, 0.) : max(-rDotL, 0.);
    uDotL = normal.y > 0. ? max(uDotL, 0.) : max(-uDotL, 0.);
    fDotL = normal.z > 0. ? max(fDotL, 0.) : max(-fDotL, 0.);
    // voxel shading average from all front sides
    nDotL = rDotL * weight.x + uDotL * weight.y + fDotL * weight.z;

    return albedo * nDotL;
}

vec4 CalculateDirectLighting(vec3 position, vec3 normal, vec3 albedo)
{
    vec3 normalizedNormal = normalize(normal);
    // world space grid voxel size
    float voxelWorldSize = 2. /  (voxelScale * volumeDimension);
    // calculate directional lighting
    vec4 directLighting = vec4(0.);
    vec4 current =  vec4(0.);
    // move position forward to avoid shadowing errors
    position = position + normalizedNormal * voxelWorldSize * 0.5;

    for(int i = 0; i != LIGHT_COUNT; ++i) {
        vec3 lightDirection;
        float attenuation;
        float visibility = 1.;

        float shadowMaxDist = 1.;
        vec3 voxelPos = WorldToVoxel(position, voxelScale, worldMinPoint);
        vec3 voxelLightDir = vec3(0.);

        getLightValues(lights[i], position, lightDirection, attenuation);

        /* Directional light */
        if(lights[i].position.w == 0.) {
            voxelLightDir = lightDirection;
        }
        /* Pointlight or Spotlight */
        else {
            vec3 lightPosT = WorldToVoxel(lights[i].position.xyz, voxelScale, worldMinPoint);
            vec3 lightDirT = lightPosT.xyz - voxelPos.xyz;
            shadowMaxDist = length(lightDirT);
            voxelLightDir = normalize(lightDirT);
        }

        if(attenuation <= 0.)
            current = vec4(0.);
        else {
            visibility = TraceShadow(voxelPos, voxelLightDir, shadowMaxDist);
            if(visibility <= 0.)
                current = vec4(0.);
            else
                current = vec4(BRDF(lightDirection, normalizedNormal, visibility * attenuation * lights[i].diffuse.rgb * albedo), visibility);
        }


        directLighting.rgb += current.rgb;
        directLighting.a += current.a;
    }

    if(LIGHT_COUNT > 0) { directLighting.a /= LIGHT_COUNT; }

    return directLighting;
}

void main()
{
    if(gl_GlobalInvocationID.x >= volumeDimension ||
        gl_GlobalInvocationID.y >= volumeDimension ||
        gl_GlobalInvocationID.z >= volumeDimension) return;

    ivec3 writePos = ivec3(gl_GlobalInvocationID);
    // voxel color
    vec4 albedo = texelFetch(voxelAlbedo, writePos, 0);

    if(albedo.a < EPSILON) { return; }

    // imageStore(voxelRadiance, writePos, vec4(voxelScale, 0., 0., 1.));
    // imageStore(voxelRadiance, writePos, albedo);

    albedo.a = 0.;
    // voxel normal in 0-1 range
    vec3 baseNormal = imageLoad(voxelNormal, writePos).xyz;
    // normal is stored in 0-1 range, restore to -1-1
    vec3 normal = DecodeNormal(baseNormal);
    // emission from voxel
    vec3 emissive = imageLoad(voxelEmissive, writePos).rgb;

    // black voxel has no irradiance diffuse
    if(any(greaterThan(albedo.rgb, vec3(0.))))
    {
        // obtain world-space position of the current voxel
        vec3 wsPosition = VoxelToWorld(writePos, voxelSize, worldMinPoint);
        // calculate direct lighting onto voxel
        albedo = CalculateDirectLighting(wsPosition, normal, albedo.rgb);
    }

    // store visibility in normal alpha
    imageStore(voxelNormal, writePos, vec4(baseNormal, albedo.a));
    // add emission
    albedo.rgb += emissive;
    albedo.a = 1.;

    imageStore(voxelRadiance, writePos, albedo);
}
