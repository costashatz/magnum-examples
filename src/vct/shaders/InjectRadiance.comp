// #version 430
#extension GL_ARB_shader_image_load_store : require
layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

#ifndef LIGHT_COUNT
#define LIGHT_COUNT 1 // define this when compiling the shader
#endif

#define M_PI 3.1415926535897932384626433832795
#define EPSILON 1e-30

layout(binding = 0) uniform sampler3D voxelAlbedo;
layout(binding = 1, rgba8) uniform image3D voxelNormal;
layout(binding = 2, rgba8) uniform readonly image3D voxelEmissive;
layout(binding = 3, rgba8) uniform writeonly image3D voxelRadiance;

layout(location = 0)
uniform int volumeDimension;
layout(location = 1)
uniform float voxelSize;
layout(location = 2)
uniform float voxelScale;
layout(location = 3)
uniform vec3 worldMinPoint;
layout(location = 4)
uniform float traceShadowHit;

struct lightSource
{
    vec4 position;
    vec4 diffuse;
    vec3 spotDirection;
    float spotExponent;
    float spotCutoff;
    float intensity;
    float constantAttenuation;
    float linearAttenuation;
    float quadraticAttenuation;
};

layout(location = 5)
uniform lightSource lights[LIGHT_COUNT];

vec3 VoxelToWorld(ivec3 pos)
{
    vec3 result = vec3(pos);
    result *= voxelSize;

    return result + worldMinPoint;
}

vec3 WorldToVoxel(vec3 position)
{
    vec3 voxelPos = position - worldMinPoint;
    return voxelPos * voxelScale;
}

vec3 EncodeNormal(vec3 normal)
{
    return normal * 0.5f + vec3(0.5f);
}

vec3 DecodeNormal(vec3 normal)
{
    return normal * 2.0f - vec3(1.0f);
}

float TraceShadow(vec3 position, vec3 direction, float maxTracingDistance)
{
    // scaling factor
    float k = traceShadowHit * traceShadowHit;
    // navigation
    float voxelTexSize = 1.0f / volumeDimension;
    // move one voxel further to avoid self collision
    float dst = voxelTexSize * 2.0f;
    vec3 samplePos = direction * dst + position;
    // control variables
    float visibility = 0.0f;
    // accumulated sample
    float traceSample = 0.0f;

    while (visibility <= 1.0f && dst <= maxTracingDistance)
    {
        if (samplePos.x < 0.0f || samplePos.y < 0.0f || samplePos.z < 0.0f
            || samplePos.x > 1.0f || samplePos.y > 1.0f || samplePos.z > 1.0f)
        {
            break;
        }

        traceSample = ceil(texture(voxelAlbedo, samplePos).a) * k;

        // hard shadows mode
        if(traceSample > 1.0f - EPSILON) { return 0.0f; }

        // accumulate
        visibility += (1.0f - visibility) * traceSample / dst;
        // move further into volume
        dst += voxelTexSize;
        samplePos = direction * dst + position;
    }

    return 1.0f - visibility;
}

// albedo should contain: material*lightDiffuse
vec3 BRDF(vec3 lightDirection, vec3 normal, vec3 albedo)
{
    float nDotL = 0.0f;

    vec3 weight = normal * normal;
    // calculate directional normal attenuation
    float rDotL = dot(vec3(1.0, 0.0, 0.0), lightDirection);
    float uDotL = dot(vec3(0.0, 1.0, 0.0), lightDirection);
    float fDotL = dot(vec3(0.0, 0.0, 1.0), lightDirection);

    rDotL = normal.x > 0.0 ? max(rDotL, 0.0) : max(-rDotL, 0.0);
    uDotL = normal.y > 0.0 ? max(uDotL, 0.0) : max(-uDotL, 0.0);
    fDotL = normal.z > 0.0 ? max(fDotL, 0.0) : max(-fDotL, 0.0);
    // voxel shading average from all front sides
    nDotL = rDotL * weight.x + uDotL * weight.y + fDotL * weight.z;

    return albedo * nDotL;
}

vec4 CalculateDirectLighting(vec3 position, vec3 normal, vec3 albedo)
{
    normal = normalize(normal);
    // world space grid voxel size
    float voxelWorldSize = 1.f /  (voxelScale * volumeDimension);
    // calculate directional lighting
    vec4 directLighting = vec4(0.0f, 0.0f, 0.0f, 0.0f);
    vec4 current =  vec4(0.0f);
    int count = 0;
    // move position forward to avoid shadowing errors
    position = position + normal * voxelWorldSize * 0.5f;

    vec3 normalizedNormal = normalize(normal);

    for(int i = 0; i != LIGHT_COUNT; ++i) {
        vec3 lightDirection;
        float attenuation;
        float visibility = 1.f;

        float shadowMaxDist = 1.f;
        vec3 voxelPos = WorldToVoxel(position);
        vec3 voxelLightDir = vec3(0.);

        /* Directional light */
        if(lights[i].position.w == 0.0) {
            attenuation = 1.0;
            lightDirection = normalize(-vec3(lights[i].position));
            voxelLightDir = lightDirection;
        }
        /* Pointlight or Spotlight */
        else {
            lightDirection = vec3(lights[i].position) - position;

            float distance = length(lightDirection);

            attenuation = lights[i].intensity / (lights[i].constantAttenuation +
                                                    distance * (lights[i].linearAttenuation + distance * lights[i].quadraticAttenuation));

            lightDirection = normalize(lightDirection);

            vec3 lightPosT = WorldToVoxel(lights[i].position.xyz);
            vec3 lightDirT = lightPosT.xyz - voxelPos.xyz;
            shadowMaxDist = length(lightDirT);
            voxelLightDir = normalize(lightDirT);

            /* Spotlight */
            if(lights[i].spotCutoff < M_PI/2.0) {
                float clampedCosine = max(0.0, dot(-lightDirection, lights[i].spotDirection));
                /* Outsise of spotlight cone? */
                if(clampedCosine < cos(lights[i].spotCutoff)) {
                    attenuation = 0.0;
                }
                else {
                    attenuation = attenuation * pow(clampedCosine, lights[i].spotExponent);
                }
            }
        }

        if(attenuation <= 0.f)
            current = vec4(0.f);
        else {
            visibility = TraceShadow(voxelPos, voxelLightDir, shadowMaxDist);
            if(visibility <= 0.f)
                current = vec4(0.f);
            else
                current = vec4(BRDF(lightDirection, normalizedNormal, visibility * attenuation * lights[i].diffuse.rgb * albedo), visibility);
        }


        directLighting.rgb += current.rgb;
        directLighting.a += current.a;
        count++;
    }

    if(count > 0) { directLighting.a /= count; }

    return directLighting;
}

void main()
{
    if(gl_GlobalInvocationID.x >= volumeDimension ||
        gl_GlobalInvocationID.y >= volumeDimension ||
        gl_GlobalInvocationID.z >= volumeDimension) return;

    ivec3 writePos = ivec3(gl_GlobalInvocationID);
    // voxel color
    vec4 albedo = texelFetch(voxelAlbedo, writePos, 0);

    if(albedo.a < EPSILON) { return; }

    // imageStore(voxelRadiance, writePos, vec4(voxelScale, 0.f, 0.f, 1.f));
    // imageStore(voxelRadiance, writePos, albedo);

    albedo.a = 0.0f;
    // voxel normal in 0-1 range
    vec3 baseNormal = imageLoad(voxelNormal, writePos).xyz;
    // normal is stored in 0-1 range, restore to -1-1
    vec3 normal = DecodeNormal(baseNormal);
    // emission from voxel
    vec3 emissive = imageLoad(voxelEmissive, writePos).rgb;

    // black voxel has no irradiance diffuse
    if(any(greaterThan(albedo.rgb, vec3(0.0f))))
    {
        // obtain world-space position of the current voxel
        vec3 wsPosition = VoxelToWorld(writePos);
        // calculate direct lighting onto voxel
        albedo = CalculateDirectLighting(wsPosition, normal, albedo.rgb);
    }

    // store visibility in normal alpha
    imageStore(voxelNormal, writePos, vec4(baseNormal, albedo.a));
    // add emission
    albedo.rgb += emissive;
    albedo.a = 1.0f;

    imageStore(voxelRadiance, writePos, albedo);
}
