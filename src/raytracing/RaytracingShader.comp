#define M_PI 3.1415926535897932384626433832795
#define FAR_CLIP  1000.0f

/* Camera model */
struct Camera {
	vec4 pos;
    vec4 dir;
    vec4 yAxis;
    vec4 xAxis;
	float tanFovY;
    float tanFovX;
};

/* Material model */
struct Material {
	vec4 diffuse;
	vec4 specular;
	vec4 emission;
	float shininess;
    /* todo: add refraction once first draft is working */
    /* todo: add textures once first draft is working */
};

/* assume counter-clockwise direction for normal */
/* vec4 for layout thing */
struct Triangle {
    /* vertices of triangle */
	vec4 A;
    vec4 B;
    vec4 C;
    /* todo: maybe include normal vectors as well */
    /* todo: maybe include texture coordinates */
};

/* Triangle object */
struct Object {
	Triangle triangle;
	int materialIndex;
};

/* Ray model */
struct Ray {
	vec3 origin;
	vec3 dir;
};

/* Light model */
struct Light {
    vec4 position;
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    /* vec4 for layout thing */
    vec4 spotDirection;
    float spotExponent;
    float spotCutoff;
    float intensity;
    float constantAttenuation;
    float linearAttenuation;
    float quadraticAttenuation;
};

/* GPU buffers with objects, materials and lights */
layout(std430, binding = 3) buffer ObjectBuffer {
	Object objects[];
};

layout(std430, binding = 4) buffer MaterialBuffer {
	Material materials[];
};

layout(std430, binding = 5) buffer LightBuffer {
	Light lights[];
};

/* camera */
uniform Camera camera;
/* viewport */
uniform uint width;
uniform uint height;
/* scene stats */
uniform uint numOfObjects;
uniform uint numOfLights;
uniform uint reflectionDepth;

/* output image */
layout(binding = 6) writeonly uniform image2D outputImage;

/* triangle ray-tracing */
/* todo: check if this is correct */
float traceTriangle(Ray r, Triangle t) {
	vec3 AB = t.B.xyz - t.A.xyz;
	vec3 AC = t.C.xyz - t.A.xyz;

	float det = determinant(mat3(AB, AC, -1. * r.dir));

	if(det == 0.0){
		return FAR_CLIP;
	}

    vec3 oA = r.origin - t.A.xyz;

    mat3 Di = inverse(mat3(AB, AC, -1. * r.dir));
    vec3 solution = Di*oA;

    if(solution.x >= -0.0001 && solution.x <= 1.0001){
        if(solution.y >= -0.0001 && solution.y <= 1.0001){
            if(solution.x + solution.y <= 1.0001){
                return solution.z;
            }
        }
    }
    return FAR_CLIP;
}

/* initial ray from camera and screen point */
Ray initRay(uint x, uint y, Camera cam) {
	Ray r;
	vec3 dir;
	float a, b, halfWidth, halfHeight;

	halfWidth = float(width) / 2.;
	halfHeight = float(height) / 2.;

	a = cam.tanFovX * ((float(x)-halfWidth+0.5) / halfWidth);
	b = cam.tanFovY * ((halfHeight - float(y)-0.5) / halfHeight);

	dir = normalize(a * cam.xAxis.xyz + b * cam.yAxis.xyz + cam.dir.xyz);

	r.dir = dir;
	r.origin = cam.pos.xyz;

	return r;
}

/* reflection ray */
Ray getReflectionRay(Ray r, int currentObject, float t) {
	vec3 hitPoint = r.origin + r.dir * t;
	vec3 N = normalize(cross((objects[currentObject].triangle.B - objects[currentObject].triangle.A).xyz,
								(objects[currentObject].triangle.C - objects[currentObject].triangle.A).xyz));

	vec3 dir = normalize(r.dir - 2 * dot(r.dir, N) * N);
	Ray ray;
    ray.origin = hitPoint + dir * 0.01;
    ray.dir = dir;

	return ray;
}

/* get light brightness/attenuation */
float getLightAttenuation(Light light, vec3 lightDirection, vec3 normalizedLightDirection) {
    /* Directional light */
    if(light.position.w == 0.0)
        return 1.;
    /* Pointlight or Spotlight */
    float dist = length(lightDirection);
    float attenuation = light.intensity / (light.constantAttenuation + 
                                                    dist * (light.linearAttenuation + dist * light.quadraticAttenuation));
    /* Spotlight */
    if(light.spotCutoff < M_PI / 2.) {
        float clampedCosine = max(0.0, dot(-normalizedLightDirection, light.spotDirection.xyz));
        /* Outsise of spotlight cone? */
        if(clampedCosine < cos(light.spotCutoff)) {
            attenuation = 0.0;
        }
        else {
            attenuation = attenuation * pow(clampedCosine, light.spotExponent);
        }
    }

    return attenuation;
}

/* get light ray with unormalized direction */
Ray getLightRay(Light light, vec3 hitPoint) {
    Ray lightRay;
    lightRay.origin = hitPoint;
    /* Directional light */
    if(light.position.w == 0.0) {
        lightRay.dir = normalize(light.position.xyz);
    }
    /* Pointlight or Spotlight */
    else {
        lightRay.dir = light.position.xyz - hitPoint; //normalize(light.position.xyz - hitPoint);
    }

    return lightRay;
}

bool intersected(Light light, float tHit, vec3 previousHitPoint) {
    /* Directional light */
    if(light.position.w == 0.0) {
        if(tHit >=0. && tHit < FAR_CLIP)
            return true;
        return false;
    }
    /* Pointlight or Spotlight */
    if(tHit >=0. && tHit < FAR_CLIP && tHit < length(light.position.xyz - previousHitPoint))
        return true;
    return false;
}

/* calculate color of at ray/triangle intersection */
vec4 calculateColor(Ray r, float t, int currentObject) {
    /* todo: add only rgb components; see what to do with alpha */
	vec4 color = vec4(0., 0., 0., 1.);

    int matIndex = objects[currentObject].materialIndex;

    /* sanity checks */
    if(currentObject == -1 || t < 0. || matIndex < 0)
        return color;

    /* add emissivity */
    Material mat = materials[matIndex];

    color += mat.emission;

    /* hitPoint and normal (N) */
    vec3 hitPoint = r.origin + t * r.dir;
    vec3 N = normalize(cross((objects[currentObject].triangle.B - objects[currentObject].triangle.A).xyz, 
									(objects[currentObject].triangle.C - objects[currentObject].triangle.A).xyz));
    
    hitPoint += 0.01 * N;

    /* iterate over lights */
    for(int i = 0; i < numOfLights; i++) {
        /* it has unormalized direction */
        Ray lightRay = getLightRay(lights[i], hitPoint);
        vec3 lightDirection = lightRay.dir;
        if(lights[i].position.w == 1.0)
            lightRay.dir = normalize(lightRay.dir);
        vec3 normalizedLightDirection = lightRay.dir;
        bool inShadow = false;

        /* check if in shadow */
        for(int j = 0; j < numOfObjects; j++) {
            float tHit = traceTriangle(lightRay, objects[i].triangle);

            if(intersected(lights[i], tHit, hitPoint)) {
                inShadow = true;
                break;
            }
        }

        float intensity = dot(N, normalizedLightDirection);

        /* if not in shadow and right side of light */
        if(!inShadow && intensity > 0.) {
            /* calculate direct light components */
            float attenuation = getLightAttenuation(lights[i], lightDirection, normalizedLightDirection);

            vec4 diffuseReflection = attenuation * lights[i].diffuse * mat.diffuse * intensity;

            vec3 reflection = reflect(-normalizedLightDirection, N);
            float specularity = pow(max(0.0, dot(normalize(camera.pos.xyz - hitPoint), reflection)), mat.shininess);
            vec4 specularReflection = attenuation * lights[i].specular * mat.specular * specularity;

            color += diffuseReflection + specularReflection;
        }

        /* add ambient component of light, no matter what */
        color += lights[i].ambient;
    }

    return color;
}

/* do the actual work */
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main(){
	uint x = gl_GlobalInvocationID.x;
	uint y = gl_GlobalInvocationID.y;

    /* sanity check */
    if(x >= width || y >= height)
        return;
    vec4 color = vec4(0., 0., 0., 1.);

    /* todo: pay attention to transformations;
     * maybe pre-transform all objects
     */

    /* initial ray from pixel and camera position */
    Ray ray = initRay(x, y, camera);

    for(int i = 0; i < reflectionDepth; i++) {
        float t = FAR_CLIP, tHit = FAR_CLIP;
        int currentObject = -1;

        for(int j = 0; j < numOfObjects; j++) {
            tHit = traceTriangle(ray, objects[i].triangle);

            if(tHit < t && tHit >= 0.) {
                currentObject = j;
                t = tHit;
            }
        }

        /* no hit */
        if(currentObject == -1)
            break;
        /* we have a hit; get lights color */
        vec4 tempColor = calculateColor(ray, t, currentObject);
        if(tempColor.rgb == vec3(0.))
            break;
        int matIndex = objects[currentObject].materialIndex;
        Material mat = materials[matIndex];

        /* no specularity, get color and break */
        if(mat.specular.rgb == vec3(0.)) {
            color += tempColor;
            break;
        }

        /* we have specular object; calculate shiny color
         * and reflection ray
         */
        color += mat.specular * tempColor;

        /* reflection ray */
        ray = getReflectionRay(ray, currentObject, t);

        /* todo: calculate refraction ray here */
    }

    imageStore(outputImage, ivec2(x, y), vec4(color.rgb, 1.));
}