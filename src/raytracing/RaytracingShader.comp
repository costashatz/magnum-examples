#define M_PI 3.1415926535897932384626433832795
#define FAR_CLIP  1000.0f
#define MAX_REFLECTION_DEPTH 5

/* Camera model */
struct Camera {
    vec3 pos;
    vec3 dir;
    vec3 yAxis;
    vec3 xAxis;
    float tanFovY;
    float tanFovX;
};

/* Material model */
struct Material {
    vec4 diffuse;
    vec4 specular;
    vec4 emission;
    float shininess;
    /* todo: add refraction once first draft is working */
    /* todo: add textures once first draft is working */
};

/* assume counter-clockwise direction for normal */
/* vec4 for layout thing */
struct Triangle {
    /* vertices of triangle */
    vec4 A;
    vec4 B;
    vec4 C;
    /* todo: maybe include normal vectors as well */
    /* todo: maybe include texture coordinates */
};

/* Triangle object */
struct Object {
    Triangle triangle;
    int materialIndex;
};

/* Ray model */
struct Ray {
    vec3 origin;
    vec3 dir;
};

/* Light model */
struct Light {
    vec4 position;
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    /* vec4 for layout thing */
    vec4 spotDirection;
    float spotExponent;
    float spotCutoff;
    float intensity;
    float constantAttenuation;
    float linearAttenuation;
    float quadraticAttenuation;
};

/* GPU buffers with objects, materials and lights */
layout(std430, binding = 3) buffer ObjectBuffer {
    Object objects[];
};

layout(std430, binding = 4) buffer MaterialBuffer {
    Material materials[];
};

layout(std430, binding = 5) buffer LightBuffer {
    Light lights[];
};

/* camera */
layout(location = 0) uniform Camera camera;
/* viewport */
layout(location = 6) uniform uint width = 640;
layout(location = 7) uniform uint height = 480;
/* scene stats */
layout(location = 8) uniform uint numOfObjects = 0;
layout(location = 9) uniform uint numOfLights = 0;
layout(location = 10) uniform uint reflectionDepth = 2;

/* output image */
layout(binding = 6, RGBA8) writeonly uniform image2D outputImage;

/* triangle ray-tracing */
/* todo: check if this is correct */
float traceTriangle(Ray r, Triangle t) {
    vec3 AB = t.B.xyz - t.A.xyz;
    vec3 AC = t.C.xyz - t.A.xyz;

    vec3 p = cross(r.dir, AC);
    float tmp = dot(p, AB);

    if (tmp > -0.00001 && tmp < 0.00001)
        return FAR_CLIP;
    tmp = 1. / tmp;

    vec3 s = r.origin - t.A.xyz;
    float u = tmp * dot(s, p);
    if(u < 0.0 || u > 1.0)
        return FAR_CLIP;

    vec3 q = cross(s, AB);
    float v = tmp * dot(r.dir, q);
    if(v < 0.0 || (u+v) > 1.0)
        return FAR_CLIP;

    float tHit = tmp * dot(AC, q);

    if (tHit < 0.)
        return FAR_CLIP;

    return tHit;
}

/* initial ray from camera and screen point */
Ray initRay(uint x, uint y, Camera cam) {
    Ray r;
    vec3 dir;
    float a, b, halfWidth, halfHeight;

    halfWidth = float(width) / 2.;
    halfHeight = float(height) / 2.;

    a = cam.tanFovX * ((float(x)-halfWidth+0.5) / halfWidth);
    b = cam.tanFovY * ((halfHeight - float(y)-0.5) / halfHeight);

    dir = normalize(a * cam.xAxis + b * cam.yAxis + cam.dir);

    r.dir = dir;
    r.origin = cam.pos;

    return r;
}

/* reflection ray */
Ray getReflectionRay(Ray r, int currentObject, float t) {
    vec3 hitPoint = r.origin + r.dir * t;
    vec3 N = normalize(cross((objects[currentObject].triangle.B - objects[currentObject].triangle.A).xyz,
                                (objects[currentObject].triangle.C - objects[currentObject].triangle.A).xyz));

    vec3 dir = reflect(r.dir, N);
    Ray ray;
    ray.origin = hitPoint + dir * 0.001;
    ray.dir = dir;

    return ray;
}

/* get light brightness/attenuation */
float getLightAttenuation(Light light, vec3 lightDirection, vec3 normalizedLightDirection) {
    /* Directional light */
    if(light.position.w == 0.0)
        return 1.;
    /* Pointlight or Spotlight */
    float dist = length(lightDirection);
    float attenuation = light.intensity / (light.constantAttenuation + 
                                                    dist * (light.linearAttenuation + dist * light.quadraticAttenuation));
    /* Spotlight */
    if(light.spotCutoff < M_PI / 2.) {
        float clampedCosine = max(0.0, dot(-normalizedLightDirection, light.spotDirection.xyz));
        /* Outsise of spotlight cone? */
        if(clampedCosine < cos(light.spotCutoff)) {
            attenuation = 0.0;
        }
        else {
            attenuation = attenuation * pow(clampedCosine, light.spotExponent);
        }
    }

    return attenuation;
}

/* get light ray with unormalized direction */
Ray getLightRay(Light light, vec3 hitPoint) {
    Ray lightRay;
    lightRay.origin = hitPoint;
    /* Directional light */
    if(light.position.w == 0.0) {
        lightRay.dir = normalize(light.position.xyz);
    }
    /* Pointlight or Spotlight */
    else {
        lightRay.dir = light.position.xyz - hitPoint; //normalize(light.position.xyz - hitPoint);
    }

    return lightRay;
}

bool intersected(Light light, float tHit, vec3 previousHitPoint) {
    /* Directional light */
    if(light.position.w == 0.0) {
        if(tHit >=0. && tHit < FAR_CLIP)
            return true;
        return false;
    }
    /* Pointlight or Spotlight */
    if(tHit >=0. && tHit < FAR_CLIP && tHit < length(light.position.xyz - previousHitPoint))
        return true;
    return false;
}

/* calculate color of at ray/triangle intersection */
vec4 calculateColor(Ray r, float t, int currentObject) {
    /* todo: add only rgb components; see what to do with alpha */
    vec4 color = vec4(0., 0., 0., 1.);

    int matIndex = objects[currentObject].materialIndex;

    /* sanity checks */
    if(currentObject == -1 || t < 0. || matIndex < 0)
        return color;

    /* add emissivity */
    Material mat = materials[matIndex];

    color += mat.emission;

    /* hitPoint and normal (N) */
    vec3 hitPoint = r.origin + t * r.dir;
    vec3 N = normalize(cross((objects[currentObject].triangle.B - objects[currentObject].triangle.A).xyz, 
                                    (objects[currentObject].triangle.C - objects[currentObject].triangle.A).xyz));
    
    hitPoint += 0.001 * N;

    /* iterate over lights */
    for(int i = 0; i < numOfLights; i++) {
        /* it has unormalized direction */
        Ray lightRay = getLightRay(lights[i], hitPoint);
        vec3 lightDirection = lightRay.dir;
        if(lights[i].position.w == 1.0)
            lightRay.dir = normalize(lightRay.dir);
        vec3 normalizedLightDirection = lightRay.dir;
        bool inShadow = false;

        /* check if in shadow */
        for(int j = 0; j < numOfObjects; j++) {
            if(j == currentObject)
                continue;
            float tHit = traceTriangle(lightRay, objects[j].triangle);

            if(intersected(lights[i], tHit, hitPoint)) {
                inShadow = true;
                break;
            }
        }

        float intensity = dot(N, normalizedLightDirection);

        /* if not in shadow and right side of light */
        if(!inShadow && intensity > 0.) {
            /* calculate direct light components */
            float attenuation = getLightAttenuation(lights[i], lightDirection, normalizedLightDirection);

            vec4 diffuseReflection = lights[i].diffuse * mat.diffuse * intensity;

            vec3 reflection = reflect(-normalizedLightDirection, N);
            float specularity = pow(max(0.0, dot(normalize(r.origin - hitPoint), reflection)), mat.shininess);
            vec4 specularReflection = lights[i].specular * mat.specular * specularity;

            color += attenuation * (diffuseReflection + specularReflection);
        }

        /* add ambient component of light, no matter what */
        color += lights[i].ambient;
    }

    return color;
}

/* do the actual work */
layout (local_size_x = 20, local_size_y = 20, local_size_z = 1) in;
void main(){
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;

    /* sanity check */
    if(x >= width || y >= height)
        return;
    vec4 color = vec4(0., 0., 0., 1.);

    /* todo: pay attention to transformations;
     * maybe pre-transform all objects
     */

    /* initial ray from pixel and camera position */
    Ray ray = initRay(x, y, camera);

    /* store reflection depth results to combine correctly */
    vec4 reflectedColors[MAX_REFLECTION_DEPTH];
    uint mats[MAX_REFLECTION_DEPTH];
    int valid[MAX_REFLECTION_DEPTH];
    uint reflectionDepthReached = 0;

    for(uint i = 0; i < reflectionDepth; i++) {
        reflectionDepthReached = i;

        float t = FAR_CLIP, tHit = FAR_CLIP;
        int currentObject = -1;

        for(int j = 0; j < numOfObjects; j++) {
            tHit = traceTriangle(ray, objects[j].triangle);

            if(tHit < t && tHit >= 0.) {
                currentObject = j;
                t = tHit;
            }
        }

        /* save if there was a hit or not */
        valid[i] = currentObject;

        /* no hit */
        if(currentObject == -1)
            break;
        /* we have a hit; get lights color */
        vec4 tempColor = calculateColor(ray, t, currentObject);
        int matIndex = objects[currentObject].materialIndex;

        /* store information for color computation */
        reflectedColors[i] = tempColor;
        mats[i] = matIndex;

        if(tempColor.rgb == vec3(0.))
            break;
        Material mat = materials[matIndex];

        /* no specularity; break */
        if(mat.specular.rgb == vec3(0.))
            break;

        /* todo: calculate refraction ray here */

        /* we have specular object; calculate reflection ray */
        ray = getReflectionRay(ray, currentObject, t);
    }

    /* decay for reflected rays */
    float decay = 0.9;
    /* compute actual colors */
    for(uint i = 0; i <= reflectionDepthReached; i++) {
        if(valid[i] < 0)
            break;
        vec4 spec = vec4(1.f);
        float d = 1.;
        if(i > 0) {
            spec = materials[mats[i-1]].specular;
            d = decay;
            decay = decay * decay;
        }
        color += d * spec * reflectedColors[i];
    }

    /* store pixel into output image */
    imageStore(outputImage, ivec2(x, y), vec4(color.rgb, 1.));
}